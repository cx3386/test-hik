
#include "hikvision.h"
#include <cstdlib>
#include <cstring>
#include <iostream>
#include "Windows.h"
#include "HCNetSDK.h"
#include "plaympeg4.h"

#include <time.h>



using namespace std;
using namespace cv;

LONG nPort = -1;

volatile int gbHandling = 0;//image interval



//解码回调 视频为YUV数据(YV12)，音频为PCM数据
void CALLBACK DecCBFun(long nPort, char * pBuf, long nSize, FRAME_INFO * pFrameInfo, long nReserved1, long nReserved2)
{
	if (gbHandling) {
		gbHandling--;
		return;
	}
	long lFrameType = pFrameInfo->nType;
	if (lFrameType == T_YV12) {

		Mat pImg(pFrameInfo->nHeight, pFrameInfo->nWidth, CV_8UC1);	//pImg = Gray

		Mat src(pFrameInfo->nHeight + pFrameInfo->nHeight / 2, pFrameInfo->nWidth, CV_8UC1, pBuf);
		cvtColor(src, pImg, CV_YUV2GRAY_YV12);
		//imshow("IPCamera", pImg);
		//waitKey(1);
		mutex.lock();
        //if (isProcessed == false)
            //imageProcessed.wait(&mutex);
		pRawImage = pImg;
        //isProcessed == false;
        imageNeedProcess.wakeOne();
		mutex.unlock();
		//  Sleep(-1);
		
        //waitKey(1);//waitkey is used for event process in opencv gui.

	}

	gbHandling = 7;//every 8 frame

}


///实时流回调
void CALLBACK fRealDataCallBack(LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void *pUser)
{
	switch (dwDataType) {
	case NET_DVR_SYSHEAD: //系统头

		if (!PlayM4_GetPort(&nPort)) { //获取播放库未使用的通道号
			break;
		}
		//m_iPort = lPort; //第一次回调的是系统头，将获取的播放库port号赋值给全局port，下次回调数据时即使用此port号播放
		if (dwBufSize > 0) {
			if (!PlayM4_SetStreamOpenMode(nPort, STREAME_REALTIME)) { //设置实时流播放模式
				break;
			}

			if (!PlayM4_OpenStream(nPort, pBuffer, dwBufSize, 10 * 1024 * 1024)) { //打开流接口
				break;
			}

			if (!PlayM4_Play(nPort, NULL)) { //播放开始
				break;
			}
			if (!PlayM4_SetDecCallBack(nPort, DecCBFun)) {
				break;
			}
		}
		break;
	case NET_DVR_STREAMDATA:   //码流数据
		if (dwBufSize > 0 && nPort != -1) {
			if (!PlayM4_InputData(nPort, pBuffer, dwBufSize)) {
				qDebug() << "error" << PlayM4_GetLastError(nPort) << endl;
				break;
			}
		}
		break;
	default: //其他数据
		if (dwBufSize > 0 && nPort != -1) {
			if (!PlayM4_InputData(nPort, pBuffer, dwBufSize)) {
				break;
			}
		}
		break;
	}
	Sleep(1);
}


void CALLBACK g_ExceptionCallBack(DWORD dwType, LONG lUserID, LONG lHandle, void *pUser)
{
	char tempbuf[256] = { 0 };
	switch (dwType) {
	case EXCEPTION_RECONNECT:    //预览时重连
		qDebug("----------reconnect--------%d\n", time(NULL));
		break;
	default:
		break;
	}
}

BOOL HikVision::hikRealPlay(HWND h)
{
	//---------------------------------------

	// 初始化
	NET_DVR_Init();
	//设置连接时间与重连时间
	NET_DVR_SetConnectTime(2000, 1);
	NET_DVR_SetReconnect(10000, true);
	//LONG lUserID;

	//---------------------------------------
	// 注册设备
	NET_DVR_DEVICEINFO_V30 struDeviceInfo;
	lUserID = NET_DVR_Login_V30("192.168.2.84", 8000, "admin", "www.cx3386.com", &struDeviceInfo);
	if (lUserID < 0) {
		qDebug("Login error, %d\n", NET_DVR_GetLastError());
		NET_DVR_Cleanup();
		return FALSE;
	}

	//---------------------------------------
	//设置异常消息回调函数
	NET_DVR_SetExceptionCallBack_V30(0, NULL, g_ExceptionCallBack, NULL);

	//---------------------------------------
	//启动预览并设置回调数据流
	//LONG lRealPlayHandle;
	//cvNamedWindow("Mywindow", 0);
	//cvNamedWindow("IPCamera", 0);

	//HWND  h = (HWND)cvGetWindowHandle("Mywindow");

	if (h == 0) {
		qDebug() << "realplay init window failed!" << endl;
	}


	NET_DVR_PREVIEWINFO struPlayInfo = { 0 };
	struPlayInfo.hPlayWnd = h;         //需要SDK解码时句柄设为有效值，仅取流不解码时可设为空
	struPlayInfo.lChannel = 1;           //预览通道号
	struPlayInfo.dwStreamType = 0;       //0-主码流，1-子码流，2-码流3，3-码流4，以此类推
	struPlayInfo.dwLinkMode = 0;         //0- TCP方式，1- UDP方式，2- 多播方式，3- RTP方式，4-RTP/RTSP，5-RSTP/HTTP
	struPlayInfo.bBlocked = 0;			//0-非阻塞取流, 1-阻塞取流, 如果阻塞SDK内部connect失败将会有5s的超时才能够返回,不适合于轮询取流操作.

	lRealPlayHandle = NET_DVR_RealPlay_V40(lUserID, &struPlayInfo, fRealDataCallBack, NULL);

	//NET_DVR_SaveRealData(lRealPlayHandle, sFileName);
	if (lRealPlayHandle < 0) {
		qDebug("NET_DVR_RealPlay_V40 error\n");
		qDebug("%d\n", NET_DVR_GetLastError());
		NET_DVR_Logout(lUserID);
		NET_DVR_Cleanup();
		return FALSE;
	}
	//waitKey();

	//Sleep(-1);


	return TRUE;
}

BOOL HikVision::hikStopRealPlay()
{
	//---------------------------------------
	//关闭预览
	if (!NET_DVR_StopRealPlay(lRealPlayHandle)) {
		return FALSE;
	}
	//注销用户

	if (!NET_DVR_Logout(lUserID)) {
		return FALSE;
	}
	//释放SDK资源

	return (NET_DVR_Cleanup());
}


